[TOC]

# C++文本处理基础知识

本文将介绍C++基础知识，以便快速上手文本处理

## 0x00 为什么要进行文本处理？

当我们得到一些游戏脚本时会出现如下情况

```
WA 3000, , 0

CG 0,cg/黒枠用棒, 250, @-40, @-100@1000
CG 1,cg/黒枠用棒, 250, @580, @100@1000

【虎春】「――くっ！　まさかこれを躱すとはっ！」

ST0 004, S005_1CA2AA_070_M, 1, 480@-1@0@0
ST.DF 004, 3, 20@20, 1
ST.CF 004, 1, 0x888888

俺の操作するアバターが絶好のタイミングで放った一撃は[n]見事に空を切った。

BG.XY 1, , 0
CG.DEL 7, 1
CG.DEL 8, 1
CG.DEL 9, 1

CG 2,cg/神姫戦演出１, 250
WA 250, , 0
```

可以看到，该段游戏脚本夹杂了一部分代码和需要加载的资源文件名

当我们对游戏进行翻译的时候肯定是不希望对着这样文本来进行翻译的

所以我们需要过滤文本，最好是能变成如下这样

~~~
Raw:【虎春】「――くっ！　まさかこれを躱すとはっ！」
Tra：这是一段翻译的文本1

Raw:俺の操作するアバターが絶好のタイミングで放った一撃は[n]見事に空を切った。
Tra:这是一段翻译的文本2
~~~

当我们把处理好的文本交给翻译，翻译完成后再把 `Tra:` 其后的文本导回到正确的地方

为了实现这种功能，我们接下来将介绍和学习一些C++标准库的内容。

## 0x01 C++对数据封装的基本概念

详见：初步了解C++对数据封装的设计思维

了解完了C++的这种设计思维，我们来介绍一些在处理文本过程中需要用到的知识点。

## 0x02 `string`

类似于我们前面介绍的 string是一个标准库 提供的模板类

所谓的标准库其实就是已经帮你写好的一堆功能的集合

你可以调用里面那些写好的功能来完成各种事情

我们之前没说过模板的概念，其实模板这个大家现在可以暂时忽略掉

有兴趣的可以去网上查查资料。

反正简单来说string是一个类，这个类可以用来方便的处理字符串。

### 0x00 创建对象

类似于我们前面自己写的 Student 类

创建一个string 类的对象可以这样写

```C++
string str;
```

可以类比`int a;`这样

但是这时候你写出来可能会给你打一个红色波浪线

```
std::string str;
```

这样写的话就正常了。

但是如果每次用string都得加一个`std::`是不是很麻烦？

这时候我们可以在外面写一个 `using namespace std;`

这样就可以不用每次都加`std::`了

这个原因和`名称空间`有关，有兴趣可以自己去查查资料

现在看起来就是这样的了

```C++
#include <iostream>
using namespace std;

int main()
{
	string str;
}
```

和我们之前的`Student`是很像是，只不过这里我们没有自己定义`string`这个类

因为`string`这个类，已经在`iostream`里面定义过了，我们可以直接拿来用。



### 0x01 赋值

好了，现在我们已经创建出一个`str`对象了，相当于之前我们已经创建出来一个`xiaoming`

现在可以对`str`赋值了，也就是把数据给他

```c++
string str;
str = "Dir-A";
```

也可以两句合成一句

```c++
string str = "Dir-A";
```

这里其实是用了`sting`的运算符重载，这个概念没说过

其实大家可以类比于构造函数，这个和构造函数是差不多的

只不过构造函数的时候我们写了括号，这里用了等于号。

也可以用另一个对象给他赋值

```c++
string str = "Dir-A";
string str2 = str;
```

执行完成后`str2`就和`str`的内容一样了。



### 0x02 查找字符串

现在我们已经把数据给他了，当然也可以调用它里面的一些方法

比如 `str.find()`这个方法，这是一个字符串查找的方法

如果它能找到你指定的字符串，会返回字符串的位置，相反的找不到会返回` string::npos`

我们可以来简单的查找一下

```C++
int main()
{
	string str = "Dir-A";
	if (str.find("ir-A") != string::npos)
	{
		//会进来吗？
	}
}
```

!=的意思是不等于，也就是说，不等于没查找到，也就是说查找到了

也就是说，如果找到了`"ir-A"`就会进入这个if里面

当然你也可以指定开始查找的位置

```C++
int main()
{
	string str = "Dir-A";
	if (str.find("ir-A",2) != string::npos)
	{
		//会进来吗？
	}
}
```

这样的意思就是从第三个字符开始查找

不写的时候默认是第0个字符（参考数值的编号）

这个时候也就是说从`"r-A"`里找`"ir-A"`显然是找不到的，不会进入if里面。



### 0x03 拼接字符串

下面为什么整体的简洁明快，将会简洁的介绍一些功能，不再赘述。

拼接两个字符串

```C++
int main()
{
	string str = "Dir-A";
	string str2 = "Hello";
	string str3 = str + str2;
}
```

执行完毕后str3就变成了 `"Dir-AHello"`

这样直接加到str2上也是可以的，执行完成后str2的情况和str3一样

当然如果你写成 `str2 += str`相当于`str2 = str2 + str1`执行完成的情况Hello会在前面。

```C++
str2 = str1 + str2;
```

当然也可以这样，不一定要加string类的对象，也可以直接加双引号的字符串

执行完成后 str2 就变成了 `"HelloGood"`

```C++
str2 = str2 + "Good";
```

值得注意的是加号不只是一个，后面加好几个加号也行。

```C++
str2 = str2 + "Good" + "Get" + "This" + "Text" + str;
```



### 0x04 复制字符串

复制字符串将用到`string`类中`substr()`这个方法

从`str2`跳过三个字符开始复制三个字符到str1中

执行完后 `str1` 为 `"loGoodGetThisTextDir-A"`

```C++
int main()
{
	string str = "Dir-A";
	string str2 = "Heelo";
	str2 = str2 + "Good" + "Get" + "This" + "Text" + str;
	string str1 = str2.substr(3);
}
```

当然你也可以指定拷贝的长度

比如我想从`str2`跳过4个字符，复制4个字符到`str1`

执行完后`str2`为`"oGo"`

```C++
string str1 = str2.substr(4,3);
```



### 0x05 获取C-Style String

所谓的 C-Style String 其实就是 C语言下定义的以00结尾的字符串

比如

```C
const char* cstr = "Dir-A";
char cstr2[] = "Dir-A";
```

当我们调用`printf()`或WINAPI的时候都需要传递这种类型的字符串

那么如何把 `std::string` 类型的字符串转换成 `c-style`类型的呢？

很简单，我们只需要调用该类提供的一个方法即可

```C++
string str = "1.txt";
char* cstr = "1.txt";
printf("%s\n",cstr);
printf("%s\n",str.c_str());
```

可以看到 `cstr` 和 `str.c_str()` 是等价的

其实本质上 `str.c_str()` 的实现就是返回 `str` 对象内部存储的字符串的首地址



### 0x06 单字符访问

在C语言中定义一个字符串的本质其实就是在一个char类型的数组里填入一个个的字符

那么既然是数组，那就支持通过下表对字符串中的字符进行访问

理所当然的，`string`也支持这种访问形式

```C++
string strx = "Dir-A";
char c = strx[1];
char cx = 'i';
```

cx 和 c 是等价的。



## 0x02 vector

相信大家对数组都不陌生，定义一个数组像是这样

```c++
int arr[10] = { 0 };//定义一个长度为10个int的数组并初始化全部元素为0
```

这个10是固定的，也就是编译完成后这个`arr`就只有10个`int`的大小

如果在程序运行的时候有不确定数量的的数据要存入数组，这个显然不行

要么就把数组定义得非常大，其实也许运行阶段要存入的输入可能比你定义的还要大。

为了解决这种不确定数量的数据要存入数组的情况，

就是说当我们处理文本的时候可能会有不确定行数的文本，

有些文本可能只有几百行有些可能有上万行，

所有我们需要一个可以动态改变大小的数组，用来存放我们的数据

那么vector就是这么一个动态的数组。



### 0x00 创建对象

在使用vector之前需要先引入相关的头文件

```
#include <vector>
```

当然还有前面说的`std::`的问题，此后不再提及。

vector的对象创建和之前稍有区别，这是因为模板类的原因

需要多提供一个用尖括号括起来的元素类型参数

类<元素类型> 对象名

这里我们创建了一个vector，里面的每一个元素都是string

```c++
#include <iostream>
#include <vector>

int main()
{
	vector<string> vecString;
}
```



### 0x01 存入元素

存入元素的方法有多种，我们只介绍一种常用的即可。

在C语言下的数组，因为大小是确定的，所有我们可以通过下表进行访问对应的位置来存入元素

而vector是动态的，默认没有大小。

比如我现在有如下的字符串

```C++
string str0 = "Dir-A";
string str1 = "Now";
string str2 = "Teaching";
string str3 = "You";
string str4 = "Vector";
```

